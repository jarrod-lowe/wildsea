// npm install --save-dev @types/node graphql path typescript
import {
  buildSchema,
  graphqlSync,
  getIntrospectionQuery,
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLFieldMap,
  GraphQLOutputType,
  isEnumType,
  isInterfaceType,
  isObjectType,
  isScalarType,
  isUnionType,
} from 'graphql';

// Function to read all data from STDIN
function readStdin(): Promise<string> {
  return new Promise((resolve, reject) => {
    let data = '';

    // @ts-ignore - VSCode can't find process, but it exists
    process.stdin.setEncoding('utf8');

    // @ts-ignore - VSCode can't find process, but it exists
    process.stdin.on('data', (chunk) => {
      data += chunk;
    });

    // @ts-ignore - VSCode can't find process, but it exists
    process.stdin.on('end', () => {
      resolve(data);
    });

    // @ts-ignore - VSCode can't find process, but it exists
    process.stdin.on('error', (err) => {
      reject(err);
    });
  });
}

// Function to generate TypeScript definitions from GraphQL schema
async function generateTypescriptFromGraphQL(schemaContent: string) {
  try {
    const schema = buildSchema(schemaContent);
    const introspectionQuery = getIntrospectionQuery();
    const introspectionResult = graphqlSync({
      schema,
      source: introspectionQuery,
    });

    if (introspectionResult.errors) {
      throw new Error(
        `Failed to execute introspection query:\n${introspectionResult.errors
          .map((err) => err.message)
          .join('\n')}`
      );
    }

    const tsCode = generateTypeScriptCode(schema);

    // @ts-ignore - VSCode can't find process, but it exists
    process.stdout.write(tsCode);
  } catch (error: any) {
    console.error(`Error generating TypeScript from GraphQL schema: ${error.message}`);
    // @ts-ignore - VSCode can't find process, but it exists
    process.exit(1);
  }
}

// Helper function to generate TypeScript code from schema, introspection data, and query strings
function generateTypeScriptCode(
  schema: GraphQLSchema,
): string {
  const queryType = schema.getQueryType();
  const mutationType = schema.getMutationType();
  const subscriptionType = schema.getSubscriptionType();

  const queries = queryType ? generateQueryStrings(queryType) : '';
  const mutations = mutationType ? generateMutationStrings(mutationType) : '';
  const subscriptions = subscriptionType ? generateSubscriptionStrings(subscriptionType) : '';

  const typesCode = `// Code generated by make-schema. DO NOT EDIT
    ${queries}

    ${mutations}

    ${subscriptions}
  `;

  return typesCode;
}

// Function to generate query strings for all fields in the Query type
function generateQueryStrings(queryType: GraphQLObjectType): string {
  const fields = queryType.getFields();
  return generateOperationStrings(fields, 'query');
}

// Function to generate mutation strings for all fields in the Mutation type
function generateMutationStrings(mutationType: GraphQLObjectType): string {
  const fields = mutationType.getFields();
  return generateOperationStrings(fields, 'mutation');
}

// Function to generate subscription strings for all fields in the Subscription type
function generateSubscriptionStrings(subscriptionType: GraphQLObjectType): string {
  const fields = subscriptionType.getFields();
  return generateOperationStrings(fields, 'subscription');
}

// Helper function to generate GraphQL operation strings
function generateOperationStrings(
  fields: GraphQLFieldMap<any, any>,
  operationType: 'query' | 'mutation' | 'subscription'
): string {
  let result = '';

  for (const [name, field] of Object.entries(fields)) {
    const args = field.args.map((arg) => `${arg.name}: $${arg.name}`).join(', ');
    const argsDef = field.args
      .map((arg) => `$${arg.name}: ${arg.type}`)
      .join(', ');

    const operationArgsDef = argsDef ? `(${argsDef})` : '';
    const fieldArgs = args ? `(${args})` : '';

    result += `
      export const ${name}${capitalize(operationType)} = \`
        ${operationType} ${name}${operationArgsDef} {
          ${name}${fieldArgs} {
            ${getFieldSelection(field.type)}
          }
        }
      \`;
    `;
  }

  return result;
}

// Helper function to determine field selection based on type
function getFieldSelection(type: GraphQLOutputType, depth: number = 0): string {
  if (depth > 3) {
    // Limit recursion depth to avoid circular references
    return '';
  }

  if ('ofType' in type && type.ofType) {
    return getFieldSelection(type.ofType, depth);
  }

  if (isUnionType(type)) {
    const possibleTypes = type.getTypes();
    const inlineFragments = possibleTypes
      .map((possibleType) => {
        const subFields = getFieldSelection(possibleType, depth + 1);
        return subFields ? `... on ${possibleType.name} { __typename ${subFields} }` : '';
      })
      .filter(Boolean);
    return inlineFragments.join(' ');
  }

  if (isObjectType(type) || isInterfaceType(type)) {
    const fields = type.getFields();
    const fieldSelections = Object.entries(fields)
      .map(([fieldName, field]) => {
        if (isScalarType(field.type) || isEnumType(field.type)) {
          return fieldName;
        } else {
          const subFields = getFieldSelection(field.type, depth + 1);
          return subFields ? `${fieldName} { ${subFields} }` : fieldName;
        }
      })
      .filter(Boolean); // Remove empty strings
    return fieldSelections.join(' ');
  }

  return ''; // Scalar types don't need field selections
}

// Helper function to capitalize a string
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Main execution function
async function main() {
  const schemaContent = await readStdin();
  await generateTypescriptFromGraphQL(schemaContent);
}

main();
