export type Key = {
    [key: string]: AttributeValue;
};
export type AttributeValue = unknown;
export type AttributeValueList = AttributeValue[];
export type ConsistentRead = boolean;
export type PutItemInputAttributeMap = {
    [key: string]: AttributeValue;
};
export type AttributeMap = {
    [key: string]: AttributeValue;
};
export type AttributeName = string;
export type AttributeNameList = AttributeName[];
export type ExpressionAttributeNameMap = {
    [key: string]: AttributeName;
};
export type ExpressionAttributeNameVariable = string;
export type ExpressionAttributeValueMap = {
    [key: string]: AttributeValue;
};
export type ExpressionAttributeValueVariable = string;
export type ConditionCheckExpression = {
    expression: string;
    expressionNames?: ExpressionAttributeNameMap;
    expressionValues?: ExpressionAttributeValueMap;
    equalsIgnore?: string[];
    consistentRead?: boolean;
    conditionalCheckFailedHandler?: {
        strategy: 'Custom' | 'Reject';
        lambdaArn?: string;
    };
};
export type TransactConditionCheckExpression = {
    expression: string;
    expressionNames?: ExpressionAttributeNameMap;
    expressionValues?: ExpressionAttributeValueMap;
    returnValuesOnConditionCheckFailure: boolean;
};
export type DynamoDBExpression = {
    expression: string;
    expressionNames?: ExpressionAttributeNameMap;
    expressionValues?: ExpressionAttributeValueMap;
};
export type DynamoDBProjectionExpression = {
    expression: string;
    expressionNames?: Record<string, string>;
};
export type DynamoDBGetItemRequest = {
    operation: 'GetItem';
    key: Key;
    consistentRead?: ConsistentRead;
    projection?: DynamoDBProjectionExpression;
};
/**
 * @deprecated Use DynamoDBGetItemRequest
 */
export type DynamoDBGetItem = DynamoDBGetItemRequest;
export type DynamoDBPutItemRequest = {
    operation: 'PutItem';
    key: Key;
    attributeValues: PutItemInputAttributeMap;
    condition?: ConditionCheckExpression;
    customPartitionKey?: string;
    populateIndexFields?: boolean;
    _version?: number;
};
export type DynamoDBUpdateItemRequest = {
    operation: 'UpdateItem';
    key: Key;
    update: DynamoDBExpression;
    condition?: ConditionCheckExpression;
    customPartitionKey?: string;
    populateIndexFields?: boolean;
    _version?: number;
};
export type DynamoDBDeleteItemRequest = {
    operation: 'DeleteItem';
    key: Key;
    condition?: ConditionCheckExpression;
    customPartitionKey?: string;
    populateIndexFields?: boolean;
    _version?: number;
};
export type DynamoDBQueryRequest = {
    operation: 'Query';
    query: DynamoDBExpression;
    index?: string;
    nextToken?: string;
    limit?: number;
    scanIndexForward?: boolean;
    consistentRead?: boolean;
    select?: 'ALL_ATTRIBUTES' | 'ALL_PROJECTED_ATTRIBUTES';
    filter?: DynamoDBExpression;
    projection?: DynamoDBProjectionExpression;
};
export type DynamoDBScanRequest = {
    operation: 'Scan';
    index?: string;
    limit?: number;
    consistentRead?: boolean;
    nextToken?: string;
    totalSegments?: number;
    segment?: number;
    filter?: DynamoDBExpression;
    projection?: DynamoDBProjectionExpression;
};
export type DynamoDBSyncRequest = {
    operation: 'Sync';
    basePartitionKey?: string;
    deltaIndexName?: string;
    limit?: number;
    nextToken?: string;
    lastSync?: number;
    filter?: DynamoDBExpression;
};
export type DynamoDBBatchGetItemRequest = {
    operation: 'BatchGetItem';
    tables: {
        [tableName: string]: {
            keys: Key[];
            consistentRead?: boolean;
            projection?: DynamoDBProjectionExpression;
        };
    };
};
export type DynamoDBBatchDeleteItemRequest = {
    operation: 'BatchDeleteItem';
    tables: {
        [tableName: string]: Key[];
    };
};
export type DynamoDBBatchPutItemRequest = {
    operation: 'BatchPutItem';
    tables: {
        [tableName: string]: PutItemInputAttributeMap[];
    };
};
export type DynamoDBTransactGetItemsRequest = {
    operation: 'TransactGetItems';
    transactItems: {
        table: string;
        key: Key;
    }[];
};
export type DynamoDBTransactWriteItemsRequest = {
    operation: 'TransactWriteItems';
    transactItems: TransactItem[];
};
type TransactItem = TransactWritePutItem | TransactWriteUpdateItem | TransactWriteDeleteItem | TransactWriteConditionCheckItem;
type TransactWritePutItem = {
    table: string;
    operation: 'PutItem';
    key: Key;
    attributeValues: PutItemInputAttributeMap;
    condition?: TransactConditionCheckExpression;
};
type TransactWriteUpdateItem = {
    table: string;
    operation: 'UpdateItem';
    key: Key;
    update: DynamoDBExpression;
    condition?: TransactConditionCheckExpression;
};
type TransactWriteDeleteItem = {
    table: string;
    operation: 'DeleteItem';
    key: Key;
    condition?: TransactConditionCheckExpression;
};
type TransactWriteConditionCheckItem = {
    table: string;
    operation: 'ConditionCheck';
    key: Key;
    condition?: TransactConditionCheckExpression;
};
export type HTTPRequest<T extends string | Record<string, unknown>> = {
    method: 'PUT' | 'POST' | 'GET' | 'DELETE' | 'PATCH';
    params?: {
        query?: {
            [key: string]: any;
        };
        headers?: {
            [key: string]: string;
        };
        body?: T;
    };
    resourcePath: string;
};
export type HTTPResult = {
    statusCode: number;
    headers?: Record<string, string>;
    body: string;
};
export type RDSRequest = {
    statements: string[];
    variableMap: Record<string, unknown>;
    variableTypeHintMap: Record<string, string>;
};
type RDSColumnMetadata = {
    /**
     * Name of the column
     */
    name?: string;
    /**
     * The label for the column.
     */
    label?: string;
    /**
     * The database-specific data type of the column.
     */
    typeName?: string;
    /**
     * The name of the schema that owns the table that includes the column.
     */
    schemaName?: string;
    /**
     * The name of the table that includes the column.
     */
    tableName?: string;
    /**
     * A value that indicates whether the column is nullable.
     */
    nullable?: number;
    /**
     * A value that indicates whether the column increments automatically.
     */
    isAutoIncrement?: boolean;
    /**
     * A value that indicates whether the column is case-sensitive.
     */
    isCaseSensitive?: boolean;
    /**
     * The type of the column.
     */
    type?: number;
    /**
     * A value that indicates whether an integer column is signed.
     */
    isSigned?: boolean;
    /**
     * A value that indicates whether the column contains currency values.
     */
    isCurrency?: boolean;
    /**
     * The precision value of a decimal number column.
     */
    precision?: number;
    /**
     * The scale value of a decimal number column.
     */
    scale?: number;
    /**
     * The type of the column.
     */
    arrayBaseColumnType?: number;
};
type RDSStructValue = {
    attributes: RDSRecordColumnValue[];
};
type RDSRecordColumnValue = {
    /**
     * A NULL value.
     */
    isNull: boolean;
    /**
     * A value for a column of BIT data type.
     */
    bitValue: boolean;
    /**
     * A value for a column of big integer data type.
     */
    bigIntValue: number;
    /**
     * A value for a column of integer data type.
     */
    intValue: number;
    /**
     * A value for a column of double data type.
     */
    doubleValue: number;
    /**
     * A value for a column of real data type.
     */
    realValue: number;
    /**
     * A value for a column of string data type.
     */
    stringValue: string;
    /**
     * A value for a column of BLOB data type.
     */
    blobValue: ArrayBuffer;
    /**
     * An array of column values.
     */
    arrayValues: RDSRecordColumnValue[];
    /**
     * A value for a column of STRUCT data type.
     */
    structValue: RDSStructValue;
};
type RDSSqlStatementResult = {
    numberOfRecordsUpdated: number;
    records: Array<RDSRecordColumnValue[]>;
    columnMetadata: RDSColumnMetadata[];
};
export type RDSResponse = {
    sqlStatementResults: RDSSqlStatementResult[];
};
export type OpenSearchRequest = {
    operation: 'GET' | 'POST' | ' PUT' | 'HEAD' | 'DELETE';
    path: string;
    params?: Partial<{
        headers: unknown;
        queryString: unknown;
        body: unknown;
    }>;
};
export type LambdaRequest = {
    operation: 'Invoke' | 'BatchInvoke';
    invocationType?: 'RequestResponse' | 'Event';
    payload: unknown;
};
export type NONERequest = {
    payload: unknown;
};
export type PutEventsRequest = {
    operation: 'PutEvents';
    events: {
        source: string;
        detail: {
            [key: string]: any;
        };
        detailType: string;
        resources?: string[];
        time?: string;
    }[];
};
export type PutEventsResult = {
    Entries: Array<{
        EventId: string;
    } | {
        ErrorCode: string;
        ErrorMessage: string;
    }>;
    FailedEntryCount: number;
};
export {};
