import { Prettify } from './type-utils';
import { RDSRequest, RDSResponse } from './resolver-return-types';
interface RDSTypeHint {
}
/**
 * A helper type that provides methods to create type hints for different SQL data types.
 * This helper facilitates the declaration of specific SQL types like DECIMAL, JSON, TIMESTAMP, etc.
 * Each method returns an instance of RDSTypeHint which represents the SQL type hint for a value.
 */
export declare type RDSTypeHintHelper = {
    DECIMAL(value: string | number): RDSTypeHint;
    JSON(value: any): RDSTypeHint;
    TIMESTAMP(value: string): RDSTypeHint;
    TIME(value: string): RDSTypeHint;
    UUID(value: string): RDSTypeHint;
    DATE(value: string): RDSTypeHint;
};
/**
 * helper methods to assign a SQL type hint to a value,
 * such as indicating a value should be treated as a TIMESTAMP,
 * JSON, UUID, etc., in SQL operations.
 */
export declare const typeHint: RDSTypeHintHelper;
type RDSEqualityOperator<T> = {
    ne?: T | null;
    eq?: T | null;
};
type RDSScalarOperator<T> = Prettify<RDSEqualityOperator<T> & {
    le?: T | null;
    lt?: T | null;
    gt?: T | null;
    ge?: T | null;
}>;
type RDSNumberOperator<T> = Prettify<RDSScalarOperator<T> & {
    between?: [T, T] | null;
}>;
type RDSStringOperator<T> = Prettify<RDSScalarOperator<T | RDSTypeHint> & {
    beginsWith?: T | null;
    contains?: T | null;
    size?: RDSNumberOperator<number>;
}>;
type RDSAttributeExistsOperator = {
    attributeExists?: boolean | null;
};
type RDSBooleanOperator<T> = RDSEqualityOperator<T>;
type RDSExpressionOperation<TOperand = unknown> = TOperand extends boolean ? Prettify<RDSBooleanOperator<NonNullable<TOperand>> & RDSAttributeExistsOperator> : TOperand extends number ? Prettify<RDSNumberOperator<NonNullable<TOperand>> & RDSAttributeExistsOperator> : TOperand extends string ? Prettify<RDSStringOperator<NonNullable<TOperand>> & RDSAttributeExistsOperator> : never;
type RDSConditionShallowObject<T = unknown> = T extends Record<string, unknown> ? Prettify<{
    [P in keyof T]?: Prettify<RDSExpressionOperation<T[P]>>;
}> : any;
type RDSConditionObject<T = unknown> = T extends Record<string, unknown> ? Prettify<RDSConditionShallowObject<NonNullable<T>> & {
    and?: RDSConditionObject<NonNullable<T>>[];
    or?: RDSConditionObject<NonNullable<T>>[];
    not?: RDSConditionObject<NonNullable<T>>[];
}> : {};
type ColumnName<T = unknown> = T extends Record<string, unknown> ? keyof T : string;
export type OrderBy<T> = {
    column: ColumnName<T>;
    dir?: 'ASC' | 'DESC' | 'asc' | 'desc';
};
type RDSAliasObject = {
    [key: string]: SQLStatement | SelectStatement | string;
};
type RDSBasePayloadWithTable = {
    /**
     * The name of the database table involved in the SQL operation. This is a required field if
     * from is not included.
     */
    table: string;
    from?: never;
};
type RDSBasePayloadWithFrom = {
    /**
     * The name of the database table involved in the SQL operation. This is a required field if
     * table is not included.
     */
    from: string | RDSAliasObject;
    table?: never;
};
type RDSBasePayload = RDSBasePayloadWithTable | RDSBasePayloadWithFrom;
type RDSBaseConditionalPayload<T = unknown> = Prettify<RDSBasePayload & {
    /**
     * An optional property that builds the where clause of a SQL operation.
     * @example
     * ``` typescript
     *  type Order = {
     *      id: number,
     *      customerId: number,
     *      price: number,
     *      quantity: number,
     *      status: string,
     * }
     * const where: RDSConditionObject<Order> = {
     *    customerId: {
     *        eq: 12123
     *    },
     *    or: [
     *      {
     *        status: { eq: "PENDING"},
     *      },
     *      {
     *        status: { eq: "SHIPPING"},
     *      }
     *    ]
     * }
     * ```
     * This will generate the following WHERE clause
     * `WHERE customerId = 12123 OR (status = "PENDING" OR status = "SHIPPING")`
     */
    where?: RDSConditionObject<T>;
}>;
export type SelectPayload<T = unknown> = Prettify<RDSBaseConditionalPayload<T> & {
    /**
     * Specifies the list of columns to be returned in the result. Defaults to '*' (all columns).
     */
    columns?: ColumnName<T>[] | '*';
    /**
     * Specifies the order by which the results should be sorted.
     */
    orderBy?: OrderBy<T>[];
    /**
     * Limits the number of results returned.
     */
    limit?: number;
    /**
     * Specifies the offset from where to start returning results.
     */
    offset?: number;
}>;
export type InsertPayload<T = unknown> = Prettify<RDSBasePayload & Partial<PGReturningPayload<T>> & {
    /**
     * required parameter values that contains data to be inserted
     */
    values: T extends Record<string, unknown> ? T : Record<string, unknown>;
}>;
export type UpdatePayload<T = unknown> = Prettify<RDSBaseConditionalPayload<T> & Partial<PGReturningPayload<T>> & {
    /**
     * required parameter values that contains values to be updated in the record
     */
    values: T extends Record<string, unknown> ? Partial<T> : Record<string, unknown>;
}>;
export type RemovePayload<T = unknown> = Prettify<Partial<PGReturningPayload<T>> & RDSBaseConditionalPayload<T>>;
type PGReturningPayload<T> = {
    /**
     * a list of columns that should be returned. Accepts `*` to return all the columns.
     * Only supported in Postgres
     */
    returning: ColumnName<T>[] | '*';
};
export interface SQLStatement {
}
export interface SelectStatement extends SQLStatement {
}
export interface InsertStatement extends SQLStatement {
}
export interface UpdateStatement extends SQLStatement {
}
export interface RemoveStatement extends SQLStatement {
}
/**
 * Generates select SQL statement
 * @example
 * ```typescript
 * import { select, createMySQLStatement } from '@aws-appsync/utils/rds';
 * export function request(ctx) {
 *     const statement1 = select({
 *       table: 'test',
 *       where: {
 *           name: {
 *             contains: 'son'
 *           }
 *       }
 *     });
 *     return createMySQLStatement(statement1);
 * }
 * ```
 * @param payload
 */
export declare function select<T = unknown>(payload: SelectPayload<T>): SelectStatement;
/**
 * Generates insert SQL statement
 * @example
 * ```typescript
 * import { insert, createMySQLStatement } from '@aws-appsync/utils/rds';
 * export function request(ctx) {
 *     const statement1 = insert({
 *       table: 'test',
 *       values: {
 *           name: "Luke Skywalker"
 *       },
 *     });
 *     return createMySQLStatement(statement1);
 * }
 * ```
 * @param payload
 */
export declare function insert<T = unknown>(payload: InsertPayload<T>): InsertStatement;
/**
 * Generates update SQL statement
 * @example
 * ```typescript
 * import { update, createMySQLStatement } from '@aws-appsync/utils/rds';
 * export function request(ctx) {
 *     const statement1 = update({
 *       table: 'test',
 *       values: {
 *           name: "Luke Skywalker"
 *       },
 *       where: {
 *           id: {
 *             eq: 12123
 *           }
 *       }
 *     });
 *     return createMySQLStatement(statement1);
 * }
 * ```
 * @param payload
 */
export declare function update<T = unknown>(payload: UpdatePayload<T>): UpdateStatement;
/**
 * A helper to generate DELETE SQL statement to delete records from table
 * @example
 * ```typescript
 * import { remove, createMySQLStatement } from '@aws-appsync/utils/rds';
 * export function request(ctx) {
 *     const statement1 = remove({
 *       table: 'test',
 *       where: { id: { eq: 112321 }}
 *     });
 *     return createMySQLStatement(statement1);
 * }
 * ```
 * @param payload
 */
export declare function remove<T = unknown>(payload: RemovePayload<T>): RemoveStatement;
type Statement = SQLStatement | string;
/**
 * Generates an RDSRequest to interacts with Postgres database. The generated
 * statements are quoted and escaped using `"` as quoting character.
 *
 * @param statement1 required statement
 * @param statement2 optional second statement
 */
export declare function createPgStatement(statement1: Statement, statement2?: Statement | null): RDSRequest;
/**
 * Generates an RDSRequest to interacts with MySQL RDS database. The generated
 * statements are quoted and escaped using backtick as quoting character.
 *
 * @param statement1 required statement
 * @param statement2 optional second statement
 */
export declare function createMySQLStatement(statement1: Statement, statement2?: Statement | null): RDSRequest;
/**
 * The tagged template allows writing a static statement that can receive dynamic values at runtime through
 * template expressions. AWS AppSync builds a variable map from the expression values to construct a
 * SqlParameterized query sent to the Amazon Aurora Serverless Data API.
 */
export declare function sql(literal: TemplateStringsArray, ...args: any[]): SQLStatement;
/**
  * Returns a object by transforming the stringified raw Amazon Relational Database Service
  * (Amazon RDS) Data API operation result format to a more concise object.
  * The returned object is a serialized list of SQL records of the result set.
  * Every record is represented as a collection of key-value pairs. The keys are
  * the corresponding column names.

  * If the corresponding statement in the input was a SQL query that causes a mutation
  * (for example INSERT, UPDATE, DELETE), then an empty list is returned.
  * For example, the query `select * from Books limit 2` provides the raw result
  * from the Amazon RDS Data operation:

  * ```
  * {
  *   "sqlStatementResults": [
  *     {
  *       "numberOfRecordsUpdated": 0,
  *       "records": [
  *         [
  *           {
  *             "stringValue": "Mark Twain"
  *           },
  *           {
  *             "stringValue": "Adventures of Huckleberry Finn"
  *           },
  *           {
  *             "stringValue": "978-1948132817"
  *           }
  *         ],
  *         [
  *           {
  *             "stringValue": "Jack London"
  *           },
  *           {
  *             "stringValue": "The Call of the Wild"
  *           },
  *           {
  *             "stringValue": "978-1948132275"
  *           }
  *         ]
  *       ],
  *       "columnMetadata": [
  *         {
  *           "isSigned": false,
  *           "isCurrency": false,
  *           "label": "author",
  *           "precision": 200,
  *           "typeName": "VARCHAR",
  *           "scale": 0,
  *           "isAutoIncrement": false,
  *           "isCaseSensitive": false,
  *           "schemaName": "",
  *           "tableName": "Books",
  *           "type": 12,
  *           "nullable": 0,
  *           "arrayBaseColumnType": 0,
  *           "name": "author"
  *         },
  *         {
  *           "isSigned": false,
  *           "isCurrency": false,
  *           "label": "title",
  *           "precision": 200,
  *           "typeName": "VARCHAR",
  *           "scale": 0,
  *           "isAutoIncrement": false,
  *           "isCaseSensitive": false,
  *           "schemaName": "",
  *           "tableName": "Books",
  *           "type": 12,
  *           "nullable": 0,
  *           "arrayBaseColumnType": 0,
  *           "name": "title"
  *         },
  *         {
  *           "isSigned": false,
  *           "isCurrency": false,
  *           "label": "ISBN-13",
  *           "precision": 15,
  *           "typeName": "VARCHAR",
  *           "scale": 0,
  *           "isAutoIncrement": false,
  *           "isCaseSensitive": false,
  *           "schemaName": "",
  *           "tableName": "Books",
  *           "type": 12,
  *           "nullable": 0,
  *           "arrayBaseColumnType": 0,
  *           "name": "ISBN-13"
  *         }
  *       ]
  *     }
  *   ]
  * }
  ```

  * The util.rds.toJson of this JSON block is:

  ```
  * [
  *   {
  *     "author": "Mark Twain",
  *     "title": "Adventures of Huckleberry Finn",
  *     "ISBN-13": "978-1948132817"
  *   },
  *   {
  *     "author": "Jack London",
  *     "title": "The Call of the Wild",
  *     "ISBN-13": "978-1948132275"
  *   }
  * ]
  *
  ```
  @param data - Serialized SQL result
  @returns Array<Array<Record<string, any>>> - Object representing SQL results
  */
export declare function toJsonObject(data: string | RDSResponse): Array<Array<Record<string, any>>>;
export {};
